
https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/sect-managing_services_with_systemd-unit_files

本文档基本都来自 redhat 的官方文档, 不过 还可同时 参考 《鸟哥的linux私房菜》获取一些官方文档没有明确说明的补充信息

10.6. creating and modifying systemd unit files

unit file 包含 描述 该 unit 和 定义 其 行为(behavior)的 配置指令. 有多个 systemctl 命令在后台是通过 unit files 来工作的.
要进行更精细的调整, 系统管理员必须手动的编辑或创建 unit files.


https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/chap-Managing_Services_with_systemd#tabl-Managing_Services_with_systemd-Introduction-Units-Locations

Table 10.2. Systemd Unit Files Locations (如下目录的优先级 从上到下为 从低到高)
------------------------------------------------------------------------------------------
/usr/lib/systemd/system/  Systemd unit files distributed with installed RPM packages. 有点类似以前的 /etc/init.d 底下的档案
/run/systemd/system/      Systemd unit files created at run time. This directory takes precedence over the directory with installed service unit files.
/etc/systemd/system/      Systemd unit files created by systemctl enable as well as unit files added for extending a service. This directory takes precedence over the directory with run time unit files. 实这个目录有点像以前 /etc/rc.d/rc5.d/Sxx 之类的功能
------------------------------------------------------------------------------------------

目录 /etc/systemd/system/ 可以给 系统管理员 用来 创建 和 定制 unit files.

Unit file names 具有如下形式:
    unit_name.type_extension

此处, unit_name 表示 unit 的名字 和 type_extension 标志了其 unit type. 如 sshd.service


Table 10.1. Available systemd Unit Types
------------------------------------------------------------------------------------------
Unit Type           File Extension    Description
------------------------------------------------------------------------------------------
Service   unit         .service         A system service.
Target    unit         .target          A group of systemd units.
Automount unit         .automount       A file system automount point.
Device    unit         .device          A device file recognized by the kernel.
Mount     unit         .mount           A file system mount point.
Path      unit         .path            A file or directory in a file system.
Scope     unit         .scope           An externally created process.
Slice     unit         .slice           A group of hierarchically organized units that manage system processes.
Snapshot  unit         .snapshot        A saved state of the systemd manager.
Socket    unit         .socket          An inter-process communication socket.
Swap      unit         .swap            A swap device or a swap file.
Timer     unit         .timer           A systemd timer.
------------------------------------------------------------------------------------------

unit files 可以 使用 额外的 configuration files 的 目录(directory) 来补充.

例如, 为了给 sshd.service 添加 自定义的 configuration options, 可以创建 sshd.service.d/custom.conf 文件 并在其中插入额外的指令(directives).

同时, 还可以创建 目录 sshd.service.wants/ 和 sshd.service.requires/. 这些目录包含了 到 作为 sshd service 的 依赖的 unit files 的 符号链接(symbolic links).
这些符号链接 可以是在 安装阶段(during installation) 根据 unit file 中的 [Install] options 自动被创建, 或在 运行时(at runtime) 基于 [Unit] options 在自动创建.
也可以手动来创建 这些 directories 和 symbolic links.


许多 unit file options 可以使用被称为 unit specifiers 的 wildcard strings 来设置,
该 wildcard strings 会在 该 unit file 被 loaded 是动态地被 unit parameters 替换.
这可以用于创建通用的 unit files 作为 生成 实例 units 的 模板(templates).


10.6.1. Understanding the Unit File Structure

unit files 典型地 由 3 部分构成:
[Unit]
    包含不依赖于 unit 类型的 通用选项(generic options). 这些 options 提供了 unit 的描述, 指定了 unit 的行为, 设置了对 其他 units 的依赖.
    常用的 [Unit] options 见 see Table 10.9, “Important [Unit] Section Options”.

[unit type]
    如果 unit 具有 类型特定的 directives, 则这些选项被组织在 以 unit type 命名的 section 下面.
    例如,  service unit files 包含 [Service] section, 更多常用的 [Service] options 见 Table 10.10, “Important [Service] Section Options”

[Install]
    包含了 systemctl enable 和 disable 命令使用的与 unit installation 相关的信息. 更多 [Install] options 的信息见 see Table 10.11, “Important [Install] Section Options”.


---------------------------------------------------------------------------------------
[root@basic ~]# cat /usr/lib/systemd/system/sshd.service
[Unit]
Description=OpenSSH server daemon
Documentation=man:sshd(8) man:sshd_config(5)
After=network.target sshd-keygen.service
Wants=sshd-keygen.service

[Service]
Type=notify
EnvironmentFile=/etc/sysconfig/sshd
ExecStart=/usr/sbin/sshd -D $OPTIONS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure
RestartSec=42s

[Install]
WantedBy=multi-user.target
[root@basic ~]#

---------------------------------------------------------------------------------------

Table 10.9. Important [Unit] Section Options (重要的 [Unit] Section 选项, 完整的 [Unit] section 选项见 man 5 systemd.unit )
------------------|--------------------------------------------------------------------------------------------------------
Option            |       Description
------------------|--------------------------------------------------------------------------------------------------------
Description       |       该unit的有意义的描述, 该 文本 会 显示在 如 systemctl status  的输出中
------------------|--------------------------------------------------------------------------------------------------------
Documentation     |       提供了 该 引用 该 unit 的 documentation 的 URIs 列表
------------------|--------------------------------------------------------------------------------------------------------
After             |       定义了 units 的启动顺序. 该 unit 只 在 After 中指定的 units 被激活(active) 之后启动(start).
                  |       不像 Requires, After 不会 显示的 去激活(activate) 指定的 units.
                  |       而 Before 选项则 具有与 After 相反的功能.
------------------|--------------------------------------------------------------------------------------------------------
Requires          |       配置 基于 其他 units 的依赖(dependencies). 在 Requires 中列出的 这些 units 会和 该 unit 一起被 激活(activated).
                  |       如果其中 任何 required units在start时失败, 则该 unit 也不会被激活(activated)
------------------|--------------------------------------------------------------------------------------------------------
Wants             |       配置 相比 Requires 更弱的依赖(weaker dependencies). 如果 Wants 列出的 units 中任何 unit 未成功启动(start),
                  |       其对该 unit 的激活(activation)没有影响. 这是推荐的 创建 自定义(custom) unit dependencies 的方式.
------------------|--------------------------------------------------------------------------------------------------------
Conflicts         |       配置 negative dependencies, 与 Requires 相反
------------------|--------------------------------------------------------------------------------------------------------

注：
    在大多数情况下, 仅通过 After 和 Before 这两个 unit file options 来设置 the ordering dependencies 就足够了. 如果你还通过
    Wants (recommended) 或 Requires 设置了 a requirement dependency, the ordering dependency 仍然需要被 指定. 那是因为
    ordering 和 requirement dependencies 是彼此 独立工作的.



Table 10.10. Important [Service] Section Options (重要的 [Service] Section 选项) (要查看完整的 options 列表见 man 5 systemd.service)
-----------------|---------------------------------------------------------------------------------------------------------
Option           |        Description
-----------------|---------------------------------------------------------------------------------------------------------
Type             |        配置 unit process 的 startup type, 该 startup type 会 影响 ExecStart 的功能 和 相关的 options. One of:
                 |
                 |        simple - 默认值, 由 ExecStart 启动(started)的 进程(process) 为该 service 的 主进程(main process)
                 |
                 |        forking – 由 ExecStart 启动(started) 的进程 产生(spawns) 一个子进程(a child process)
                 |                  作为 service 的 主进程. 其父进程在startup完成时退出(exit)
                 |
                 |        oneshot – 该type类似于 simple, 但是该 进程 在启动(start) 随后的 units 之前就 退出(exit)了.
                 |
                 |        dbus – 该type类似于 simple, 但是随后的 units 只有在 主进程 获取(gains)了 D-Bus name 之后 才会被 启动(started)
                 |
                 |        notify – 该type类似于 simple, 但随后的 units 只有在 a notification message 通过 sd_notify() 函数 发送(sent) 之后 才被 启动(started)
                 |
                 |        idle – 类似于 simple, 该 service binary 的实际执行 会延迟(delayed) 直到 all jobs 结束,
                 |               这避免了 将 the status output 与 shell output of services 混淆(mix).
-----------------|---------------------------------------------------------------------------------------------------------
ExecStart        |        指定在 unit 被启动(started) 时 被执行的 commands 或 scripts.
                 |        ExecStartPre 和 ExecStartPost 指定 自定义的 在 ExecStart 之前(before) 或 之后(after) 执行的 commands.
                 |        Type=oneshot 使其能够 指定 多个 按顺序执行的 自定义的 commands.
-----------------|---------------------------------------------------------------------------------------------------------
ExecStop         |        指定 当 该 unit 被 stopped 时 被执行的 commands 或 scripts.
-----------------|---------------------------------------------------------------------------------------------------------
ExecReload       |        指定 当 该 unit 被 reloaded 时 被执行的 commands 或 scripts
-----------------|---------------------------------------------------------------------------------------------------------
Restart          |        如果该 option 被启用(enabled), 该 service 将在其 process 退出(exits) 时 被重新启动(restarted)
                 |        除非 a clean stop by the systemctl command.
-----------------|---------------------------------------------------------------------------------------------------------
RemainAfterExit  |        如果设置为 True, 该 service 被视为 active 即使 其 所有的 processes 都退出了. 默认值为 False.
                 |        该 option 在 配置了 Type=oneshot 时 特别有用.
-----------------|---------------------------------------------------------------------------------------------------------





Table 10.11. Important [Install] Section Options (完整的选项信息见  man 5 systemd.unit)
-----------------|---------------------------------------------------------------------------------------------------------
Option           |               Description
-----------------|---------------------------------------------------------------------------------------------------------
Alias            |      提供 该 unit 的 额外的 由 space 分隔的 names. 大多数 systemctl 命令, 除 systemctl enable, 都能使用 aliases 来替代 其实际的 unit name.
-----------------|---------------------------------------------------------------------------------------------------------
RequiredBy       |      一个 要 依赖 该 unit 的 units 的列表. 如果该 unit 被 启用(enabled), 则 RequiredBy 中列出的 units 获取了 在 该 unit 上的 Require dependency.
-----------------|---------------------------------------------------------------------------------------------------------
WantedBy         |      弱依赖(weakly depend)该 unit 的 units 的列表. 当该 unit 被启用(enabled) 时, 则 WantedBy 中列出的 units 获取了 该 unit 上的 Want dependency.
-----------------|---------------------------------------------------------------------------------------------------------
Also             |      指定 要 伴随该 unit 一起 被 installed or uninstalled 的 units 的列表.
-----------------|---------------------------------------------------------------------------------------------------------
DefaultInstance  |      instantiated units 的 限制(Limited), 该 option 指定了 该 unit 对其 enabled 的 default instance. 见See Section 10.6.5, “Working with Instantiated Units”
-----------------|---------------------------------------------------------------------------------------------------------






---------------------------------------------------------------------------------------------------------------------------
Example 10.17. postfix.service Unit File

[root@basic ~]# systemctl status postfix.service
● postfix.service - Postfix Mail Transport Agent
   Loaded: loaded (/usr/lib/systemd/system/postfix.service; enabled; vendor preset: disabled)
   Active: active (running) since Sat 2019-05-11 19:02:04 CST; 39min ago
  Process: 930 ExecStart=/usr/sbin/postfix start (code=exited, status=0/SUCCESS)
  Process: 927 ExecStartPre=/usr/libexec/postfix/chroot-update (code=exited, status=0/SUCCESS)
  Process: 917 ExecStartPre=/usr/libexec/postfix/aliasesdb (code=exited, status=0/SUCCESS)
 Main PID: 1002 (master)
   CGroup: /system.slice/postfix.service
           ├─1002 /usr/libexec/postfix/master -w
           ├─1003 pickup -l -t unix -u
           └─1004 qmgr -l -t unix -u


[root@basic ~]# cat /usr/lib/systemd/system/postfix.service    # 观察 the postfix.service unit file
[Unit]
Description=Postfix Mail Transport Agent
# 指定 了顺序依赖, 即 只有 syslog.target network.target 被激活之后, 该 unit  才能被启动
After=syslog.target network.target
# 指定的 negative dependencies, 即 该 unit 与 sendmail.service exim.service 冲突
Conflicts=sendmail.service exim.service

[Service]
Type=forking
# 指定 该 service 的主进程 (main process) 的 a stable PID
PIDFile=/var/spool/postfix/pid/master.pid
# 指定了 该 service 的 环境变量(environment variables) 被定义的位置
EnvironmentFile=-/etc/sysconfig/network
ExecStartPre=-/usr/libexec/postfix/aliasesdb
ExecStartPre=-/usr/libexec/postfix/chroot-update
# 指定该 unit 被 启动(start) 时 执行的 commands 或 scripts
ExecStart=/usr/sbin/postfix start
ExecReload=/usr/sbin/postfix reload
ExecStop=/usr/sbin/postfix stop

[Install]
# 列出弱依赖 该unit 的 units
WantedBy=multi-user.target

---------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------
10.6.2. Creating Custom Unit Files (创建自定义的 unit files)

有几种 从头开始 创建 unit files 的用例(use cases):

你 可以 运行 自定义的 守护进程(daemon), 创建 一些已存在的 service 的 第二个 实例(instance)(如 as in Example 10.19, “Creating a second instance of the sshd service”),
或者 导入 a SysV init script (more in Section 10.6.3, “Converting SysV Init Scripts to Unit Files”). 另一方面, 如果你仅想 修改(modify) 或 扩展(extend) 已存在的unit
的行为(behavior), 使用 Section 10.6.4, “Modifying Existing Unit Files” 中的 instructions.
下面的 过程(procedure) 描述了 创建 自定义的 service 的 通用 步骤(process):

1. 准备 自定义 service 的 executable file. 这可以是 自定义创建的 script, 或 由 软件提供者 实现的 可执行 文件.
   如果必要, 准备一个 PID file 来 保持(hold) 该自定义 service 的 主进程的 constant PID.  也可以包含 environment files
   用于存储该 service 的 shell variables.  Make sure the source script is executable (by executing the chmod a+x) and is not interactive.

2. 在 /etc/systemd/system/ 目录中创建 unit file 并 确保 其 拥有 正确的 file permissions. 以 root 身份执行:

      touch /etc/systemd/system/name.service
      chmod 664 /etc/systemd/system/name.service

   用创建的 service 的 name 替换如上命令中的 name. Note that file does not need to be executable.

3. open 前一步 创建的 name.service file, 并 添加 该 service 的 configuration options. 存在各种 依赖于你希望创建的 service 的type 的 options 可被使用.
   see Section 10.6.1, “Understanding the Unit File Structure”. The following is an example unit configuration for a network-related service:

[Unit]
# 该 service_description 是显示在 journal log files中 或 systemctl status 命令的输出(output)中的 通知描述
Description=service_description
# 该 After 设置保证 该 service 仅在 the network is running 之后才被 started. 添加以 space 分隔的其他相关的 services 或 targets 的 列表
After=network.target

[Service]
# path_to_executable 代表 实际的 service executable 的 path
ExecStart=path_to_executable
# 配置Type=forking 被守护进程(daemons) 用于发起 fork 系统调用(system call). 该 service 的 主进程(main process) 的 PID 在 path_to_pidfile 中保存着.
Type=forking
PIDFile=path_to_pidfile

[Install]
# 配置 WantedBy 用于声明 该 service 应该在 其下 被启动(started) 的 target 或 targets. 可把 targets 理解为是 旧的 runlevels 的概念的替代
WantedBy=default.target
---------------------------------
4. 通过执行以root身份执行如下命令来 通知 systemd 一个新的 name.service 存在了:

          systemctl daemon-reload
          systemctl start name.service

       systemctl daemon-reload 命令的作用:
           Reload systemd manager configuration. This will rerun all generators (see systemd.generator(7)), reload all unit files,
           and recreate the entire dependency tree. While the daemon is being reloaded, all sockets systemd
           listens on behalf of user configuration will stay accessible.


Warning 警告!!!!!!!!!!!
    总是应该 在创建了 新的 unit files 或者 修改了 已存在的 unit files 之后 执行 systemctl daemon-reload 命令.
    否则, 命令 systemctl start 或 systemctl enable 可能因为 systemd 的状态(state) 与 磁盘上 实际的 service unit files 不匹配 而 失败.

现在 name.service unit 就能够像 任何其他 system service 那样被管理(managed)了.
---------------------------------------------------------------------------------------------------------------------------



---------------------------------------------------------------------------------------------------------------------------
Example 10.18. Creating the emacs.service File (示例:创建 emacs.service 文件)

当 使用 Emacs 文本编辑器(editor) 时, 通常 将其 运行在 后台 而非 在每当 编辑一个 file 时启动 该编辑器程序的一个实例 会更加 faster 和 convenient.
如下的步骤 演示了 如何为 Emacs 创建 一个 unit file, 因此其 就可以被 当做 a service 来处理了.

1. 在 目录 /etc/systemd/system/ 创建 a unit file 并 确保 其 具有 正确的 file permissions. 以 root 身份 执行:

[root@basic ~]# touch /etc/systemd/system/emacs.service
[root@basic ~]# chmod 664 /etc/systemd/system/emacs.service

[root@basic ~]# which emacs
/usr/bin/emacs

2. 在文件 /etc/systemd/system/emacs.service 中 添加如下内容:
[root@basic ~]# vim /etc/systemd/system/emacs.service
[Unit]
Description=Emacs: the extensible, self-documenting text editor

[Service]
Type=forking
ExecStart=/usr/bin/emacs --daemon
ExecStop=/usr/bin/emacsclient --eval "(kill-emacs)"
Environment=SSH_AUTH_SOCK=%t/keyring/ssh
Restart=always

[Install]
WantedBy=default.target


  通过 如上的 配置, /usr/bin/emacs 可执行程序 将在 该 service start 时 以 daemon mode 模式被 启动(started).
  其中的环境变量 SSH_AUTH_SOCK 的设置中 使用了 "%t" unit specifier (其表示 运行时目录).
  如果意外退出(exits), 该 服务还会 重新启动(restarts) 该 emacs 的进程(process)


3. 执行 如下 的命令 来 reload the configuration and start the custom service:

[root@basic ~]# systemctl daemon-reload
[root@basic ~]# systemctl start emacs.service

  因为 现在 emacs editor 已经被注册(registered)为 了一个 systemd service, 所以你能够使用所有的 systemctl 命令.
  例如, 执行 systemctl status emacs 来显示(display) 该 editor 的 状态(status)
  或 执行    systemctl enable emacs  来使 该 editor 在 system boot 时 自动启动(start).

[root@basic ~]# systemctl status emacs   # 创建 emacs service unit 的状态
● emacs.service - Emacs: the extensible, self-documenting text editor
   Loaded: loaded (/etc/systemd/system/emacs.service; disabled; vendor preset: disabled)
   Active: active (running) since Sun 2019-05-12 09:12:49 CST; 28s ago
  Process: 1951 ExecStart=/usr/bin/emacs --daemon (code=exited, status=0/SUCCESS)
 Main PID: 1952 (emacs)
   CGroup: /system.slice/emacs.service
           └─1952 /usr/bin/emacs --daemon

May 12 09:12:49 basic systemd[1]: Starting Emacs: the extensible, self-documenting text editor...
May 12 09:12:49 basic emacs[1951]: ("/usr/bin/emacs")
May 12 09:12:49 basic emacs[1951]: Loading /usr/share/emacs/site-lisp/site-start.d/git-init.el (source)...
May 12 09:12:49 basic emacs[1951]: Loading /usr/share/emacs/site-lisp/site-start.d/git-init.el (source)...done
May 12 09:12:49 basic emacs[1951]: Starting Emacs daemon.
May 12 09:12:49 basic systemd[1]: Started Emacs: the extensible, self-documenting text editor.

[root@basic ~]# systemctl enable emacs  # 设置 emacs service unit 开机自启
Created symlink from /etc/systemd/system/default.target.wants/emacs.service to /etc/systemd/system/emacs.service.

---------------------------------------------------------------------------------------------------------------------------



























