
https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/sect-managing_services_with_systemd-unit_files

本文档基本都来自 redhat 的官方文档, 不过 还可同时 参考 《鸟哥的linux私房菜》获取一些官方文档没有明确说明的补充信息

10.6. creating and modifying systemd unit files

unit file 包含 描述 该 unit 和 定义 其 行为(behavior)的 配置指令. 有多个 systemctl 命令在后台是通过 unit files 来工作的.
要进行更精细的调整, 系统管理员必须手动的编辑或创建 unit files.


https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/chap-Managing_Services_with_systemd#tabl-Managing_Services_with_systemd-Introduction-Units-Locations

Table 10.2. Systemd Unit Files Locations (如下目录的优先级 从上到下为 从低到高)
------------------------------------------------------------------------------------------
/usr/lib/systemd/system/  Systemd unit files distributed with installed RPM packages. 有点类似以前的 /etc/init.d 底下的档案
/run/systemd/system/      Systemd unit files created at run time. This directory takes precedence over the directory with installed service unit files.
/etc/systemd/system/      Systemd unit files created by systemctl enable as well as unit files added for extending a service. This directory takes precedence over the directory with run time unit files. 实这个目录有点像以前 /etc/rc.d/rc5.d/Sxx 之类的功能
------------------------------------------------------------------------------------------

目录 /etc/systemd/system/ 可以给 系统管理员 用来 创建 和 定制 unit files.

Unit file names 具有如下形式:
    unit_name.type_extension

此处, unit_name 表示 unit 的名字 和 type_extension 标志了其 unit type. 如 sshd.service


Table 10.1. Available systemd Unit Types
------------------------------------------------------------------------------------------
Unit Type           File Extension    Description
------------------------------------------------------------------------------------------
Service   unit         .service         A system service.
Target    unit         .target          A group of systemd units.
Automount unit         .automount       A file system automount point.
Device    unit         .device          A device file recognized by the kernel.
Mount     unit         .mount           A file system mount point.
Path      unit         .path            A file or directory in a file system.
Scope     unit         .scope           An externally created process.
Slice     unit         .slice           A group of hierarchically organized units that manage system processes.
Snapshot  unit         .snapshot        A saved state of the systemd manager.
Socket    unit         .socket          An inter-process communication socket.
Swap      unit         .swap            A swap device or a swap file.
Timer     unit         .timer           A systemd timer.
------------------------------------------------------------------------------------------

unit files 可以 使用 额外的 configuration files 的 目录(directory) 来补充.

例如, 为了给 sshd.service 添加 自定义的 configuration options, 可以创建 sshd.service.d/custom.conf 文件 并在其中插入额外的指令(directives).

同时, 还可以创建 目录 sshd.service.wants/ 和 sshd.service.requires/. 这些目录包含了 到 作为 sshd service 的 依赖的 unit files 的 符号链接(symbolic links).
这些符号链接 可以是在 安装阶段(during installation) 根据 unit file 中的 [Install] options 自动被创建, 或在 运行时(at runtime) 基于 [Unit] options 在自动创建.
也可以手动来创建 这些 directories 和 symbolic links.


许多 unit file options 可以使用被称为 unit specifiers 的 wildcard strings 来设置,
该 wildcard strings 会在 该 unit file 被 loaded 是动态地被 unit parameters 替换.
这可以用于创建通用的 unit files 作为 生成 实例 units 的 模板(templates).


10.6.1. Understanding the Unit File Structure

unit files 典型地 由 3 部分构成:
[Unit]
    包含不依赖于 unit 类型的 通用选项(generic options). 这些 options 提供了 unit 的描述, 指定了 unit 的行为, 设置了对 其他 units 的依赖.
    常用的 [Unit] options 见 see Table 10.9, “Important [Unit] Section Options”.

[unit type]
    如果 unit 具有 类型特定的 directives, 则这些选项被组织在 以 unit type 命名的 section 下面.
    例如,  service unit files 包含 [Service] section, 更多常用的 [Service] options 见 Table 10.10, “Important [Service] Section Options”

[Install]
    包含了 systemctl enable 和 disable 命令使用的与 unit installation 相关的信息. 更多 [Install] options 的信息见 see Table 10.11, “Important [Install] Section Options”.


---------------------------------------------------------------------------------------
[root@basic ~]# cat /usr/lib/systemd/system/sshd.service
[Unit]
Description=OpenSSH server daemon
Documentation=man:sshd(8) man:sshd_config(5)
After=network.target sshd-keygen.service
Wants=sshd-keygen.service

[Service]
Type=notify
EnvironmentFile=/etc/sysconfig/sshd
ExecStart=/usr/sbin/sshd -D $OPTIONS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure
RestartSec=42s

[Install]
WantedBy=multi-user.target
[root@basic ~]#

---------------------------------------------------------------------------------------

Table 10.9. Important [Unit] Section Options (重要的 [Unit] Section 选项, 完整的 [Unit] section 选项见 man 5 systemd.unit )
------------------|--------------------------------------------------------------------------------------------------------
Option            |       Description
------------------|--------------------------------------------------------------------------------------------------------
Description       |       该unit的有意义的描述, 该 文本 会 显示在 如 systemctl status  的输出中
------------------|--------------------------------------------------------------------------------------------------------
Documentation     |       提供了 该 引用 该 unit 的 documentation 的 URIs 列表
------------------|--------------------------------------------------------------------------------------------------------
After             |       定义了 units 的启动顺序. 该 unit 只 在 After 中指定的 units 被激活(active) 之后启动(start).
                  |       不像 Requires, After 不会 显示的 去激活(activate) 指定的 units.
                  |       而 Before 选项则 具有与 After 相反的功能.
------------------|--------------------------------------------------------------------------------------------------------
Requires          |       配置 基于 其他 units 的依赖(dependencies). 在 Requires 中列出的 这些 units 会和 该 unit 一起被 激活(activated).
                  |       如果其中 任何 required units在start时失败, 则该 unit 也不会被激活(activated)
------------------|--------------------------------------------------------------------------------------------------------
Wants             |       配置 相比 Requires 更弱的依赖(weaker dependencies). 如果 Wants 列出的 units 中任何 unit 未成功启动(start),
                  |       其对该 unit 的激活(activation)没有影响. 这是推荐的 创建 自定义(custom) unit dependencies 的方式.
------------------|--------------------------------------------------------------------------------------------------------
Conflicts         |       配置 negative dependencies, 与 Requires 相反
------------------|--------------------------------------------------------------------------------------------------------

注：
    在大多数情况下, 仅通过 After 和 Before 这两个 unit file options 来设置 the ordering dependencies 就足够了. 如果你还通过
    Wants (recommended) 或 Requires 设置了 a requirement dependency, the ordering dependency 仍然需要被 指定. 那是因为
    ordering 和 requirement dependencies 是彼此 独立工作的.



Table 10.10. Important [Service] Section Options (重要的 [Service] Section 选项) (要查看完整的 options 列表见 man 5 systemd.service)
-----------------|---------------------------------------------------------------------------------------------------------
Option           |        Description
-----------------|---------------------------------------------------------------------------------------------------------
Type             |        配置 unit process 的 startup type, 该 startup type 会 影响 ExecStart 的功能 和 相关的 options. One of:
                 |
                 |        simple - 默认值, 由 ExecStart 启动(started)的 进程(process) 为该 service 的 主进程(main process)
                 |
                 |        forking – 由 ExecStart 启动(started) 的进程 产生(spawns) 一个子进程(a child process)
                 |                  作为 service 的 主进程. 其父进程在startup完成时退出(exit)
                 |
                 |        oneshot – 该type类似于 simple, 但是该 进程 在启动(start) 随后的 units 之前就 退出(exit)了.
                 |
                 |        dbus – 该type类似于 simple, 但是随后的 units 只有在 主进程 获取(gains)了 D-Bus name 之后 才会被 启动(started)
                 |
                 |        notify – 该type类似于 simple, 但随后的 units 只有在 a notification message 通过 sd_notify() 函数 发送(sent) 之后 才被 启动(started)
                 |
                 |        idle – 类似于 simple, 该 service binary 的实际执行 会延迟(delayed) 直到 all jobs 结束,
                 |               这避免了 将 the status output 与 shell output of services 混淆(mix).
-----------------|---------------------------------------------------------------------------------------------------------
ExecStart        |        指定在 unit 被启动(started) 时 被执行的 commands 或 scripts.
                 |        ExecStartPre 和 ExecStartPost 指定 自定义的 在 ExecStart 之前(before) 或 之后(after) 执行的 commands.
                 |        Type=oneshot 使其能够 指定 多个 按顺序执行的 自定义的 commands.
-----------------|---------------------------------------------------------------------------------------------------------
ExecStop         |        指定 当 该 unit 被 stopped 时 被执行的 commands 或 scripts.
-----------------|---------------------------------------------------------------------------------------------------------
ExecReload       |        指定 当 该 unit 被 reloaded 时 被执行的 commands 或 scripts
-----------------|---------------------------------------------------------------------------------------------------------
Restart          |        如果该 option 被启用(enabled), 该 service 将在其 process 退出(exits) 时 被重新启动(restarted)
                 |        除非 a clean stop by the systemctl command.
-----------------|---------------------------------------------------------------------------------------------------------
RemainAfterExit  |        如果设置为 True, 该 service 被视为 active 即使 其 所有的 processes 都退出了. 默认值为 False.
                 |        该 option 在 配置了 Type=oneshot 时 特别有用.
-----------------|---------------------------------------------------------------------------------------------------------





Table 10.11. Important [Install] Section Options (完整的选项信息见  man 5 systemd.unit)
-----------------|---------------------------------------------------------------------------------------------------------
Option           |               Description
-----------------|---------------------------------------------------------------------------------------------------------
Alias            |      提供 该 unit 的 额外的 由 space 分隔的 names. 大多数 systemctl 命令, 除 systemctl enable, 都能使用 aliases 来替代 其实际的 unit name.
-----------------|---------------------------------------------------------------------------------------------------------
RequiredBy       |      一个 要 依赖 该 unit 的 units 的列表. 如果该 unit 被 启用(enabled), 则 RequiredBy 中列出的 units 获取了 在 该 unit 上的 Require dependency.
-----------------|---------------------------------------------------------------------------------------------------------
WantedBy         |      弱依赖(weakly depend)该 unit 的 units 的列表. 当该 unit 被启用(enabled) 时, 则 WantedBy 中列出的 units 获取了 该 unit 上的 Want dependency.
-----------------|---------------------------------------------------------------------------------------------------------
Also             |      指定 要 伴随该 unit 一起 被 installed or uninstalled 的 units 的列表.
-----------------|---------------------------------------------------------------------------------------------------------
DefaultInstance  |      instantiated units 的 限制(Limited), 该 option 指定了 该 unit 对其 enabled 的 default instance. 见See Section 10.6.5, “Working with Instantiated Units”
-----------------|---------------------------------------------------------------------------------------------------------






---------------------------------------------------------------------------------------------------------------------------
Example 10.17. postfix.service Unit File

[root@basic ~]# systemctl status postfix.service
● postfix.service - Postfix Mail Transport Agent
   Loaded: loaded (/usr/lib/systemd/system/postfix.service; enabled; vendor preset: disabled)
   Active: active (running) since Sat 2019-05-11 19:02:04 CST; 39min ago
  Process: 930 ExecStart=/usr/sbin/postfix start (code=exited, status=0/SUCCESS)
  Process: 927 ExecStartPre=/usr/libexec/postfix/chroot-update (code=exited, status=0/SUCCESS)
  Process: 917 ExecStartPre=/usr/libexec/postfix/aliasesdb (code=exited, status=0/SUCCESS)
 Main PID: 1002 (master)
   CGroup: /system.slice/postfix.service
           ├─1002 /usr/libexec/postfix/master -w
           ├─1003 pickup -l -t unix -u
           └─1004 qmgr -l -t unix -u


[root@basic ~]# cat /usr/lib/systemd/system/postfix.service    # 观察 the postfix.service unit file
[Unit]
Description=Postfix Mail Transport Agent
# 指定 了顺序依赖, 即 只有 syslog.target network.target 被激活之后, 该 unit  才能被启动
After=syslog.target network.target
# 指定的 negative dependencies, 即 该 unit 与 sendmail.service exim.service 冲突
Conflicts=sendmail.service exim.service

[Service]
Type=forking
# 指定 该 service 的主进程 (main process) 的 a stable PID
PIDFile=/var/spool/postfix/pid/master.pid
# 指定了 该 service 的 环境变量(environment variables) 被定义的位置
EnvironmentFile=-/etc/sysconfig/network
ExecStartPre=-/usr/libexec/postfix/aliasesdb
ExecStartPre=-/usr/libexec/postfix/chroot-update
# 指定该 unit 被 启动(start) 时 执行的 commands 或 scripts
ExecStart=/usr/sbin/postfix start
ExecReload=/usr/sbin/postfix reload
ExecStop=/usr/sbin/postfix stop

[Install]
# 列出弱依赖 该unit 的 units
WantedBy=multi-user.target

---------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------
10.6.2. Creating Custom Unit Files (创建自定义的 unit files)

有几种 从头开始 创建 unit files 的用例(use cases):

你 可以 运行 自定义的 守护进程(daemon), 创建 一些已存在的 service 的 第二个 实例(instance)(如 as in Example 10.19, “Creating a second instance of the sshd service”),
或者 导入 a SysV init script (more in Section 10.6.3, “Converting SysV Init Scripts to Unit Files”). 另一方面, 如果你仅想 修改(modify) 或 扩展(extend) 已存在的unit
的行为(behavior), 使用 Section 10.6.4, “Modifying Existing Unit Files” 中的 instructions.
下面的 过程(procedure) 描述了 创建 自定义的 service 的 通用 步骤(process):

1. 准备 自定义 service 的 executable file. 这可以是 自定义创建的 script, 或 由 软件提供者 实现的 可执行 文件.
   如果必要, 准备一个 PID file 来 保持(hold) 该自定义 service 的 主进程的 constant PID.  也可以包含 environment files
   用于存储该 service 的 shell variables.  Make sure the source script is executable (by executing the chmod a+x) and is not interactive.

2. 在 /etc/systemd/system/ 目录中创建 unit file 并 确保 其 拥有 正确的 file permissions. 以 root 身份执行:

      touch /etc/systemd/system/name.service
      chmod 664 /etc/systemd/system/name.service

   用创建的 service 的 name 替换如上命令中的 name. Note that file does not need to be executable.

3. open 前一步 创建的 name.service file, 并 添加 该 service 的 configuration options. 存在各种 依赖于你希望创建的 service 的type 的 options 可被使用.
   see Section 10.6.1, “Understanding the Unit File Structure”. The following is an example unit configuration for a network-related service:

[Unit]
# 该 service_description 是显示在 journal log files中 或 systemctl status 命令的输出(output)中的 通知描述
Description=service_description
# 该 After 设置保证 该 service 仅在 the network is running 之后才被 started. 添加以 space 分隔的其他相关的 services 或 targets 的 列表
After=network.target

[Service]
# path_to_executable 代表 实际的 service executable 的 path
ExecStart=path_to_executable
# 配置Type=forking 被守护进程(daemons) 用于发起 fork 系统调用(system call). 该 service 的 主进程(main process) 的 PID 在 path_to_pidfile 中保存着.
Type=forking
PIDFile=path_to_pidfile

[Install]
# 配置 WantedBy 用于声明 该 service 应该在 其下 被启动(started) 的 target 或 targets. 可把 targets 理解为是 旧的 runlevels 的概念的替代
WantedBy=default.target
---------------------------------
4. 通过执行以root身份执行如下命令来 通知 systemd 一个新的 name.service 存在了:

          systemctl daemon-reload
          systemctl start name.service

       systemctl daemon-reload 命令的作用:
           Reload systemd manager configuration. This will rerun all generators (see systemd.generator(7)), reload all unit files,
           and recreate the entire dependency tree. While the daemon is being reloaded, all sockets systemd
           listens on behalf of user configuration will stay accessible.


Warning 警告!!!!!!!!!!!
    总是应该 在创建了 新的 unit files 或者 修改了 已存在的 unit files 之后 执行 systemctl daemon-reload 命令.
    否则, 命令 systemctl start 或 systemctl enable 可能因为 systemd 的状态(state) 与 磁盘上 实际的 service unit files 不匹配 而 失败.

现在 name.service unit 就能够像 任何其他 system service 那样被管理(managed)了.
---------------------------------------------------------------------------------------------------------------------------



---------------------------------------------------------------------------------------------------------------------------
Example 10.18. Creating the emacs.service File (示例:创建 emacs.service 文件)

当 使用 Emacs 文本编辑器(editor) 时, 通常 将其 运行在 后台 而非 在每当 编辑一个 file 时启动 该编辑器程序的一个实例 会更加 faster 和 convenient.
如下的步骤 演示了 如何为 Emacs 创建 一个 unit file, 因此其 就可以被 当做 a service 来处理了.

1. 在 目录 /etc/systemd/system/ 创建 a unit file 并 确保 其 具有 正确的 file permissions. 以 root 身份 执行:

[root@basic ~]# touch /etc/systemd/system/emacs.service
[root@basic ~]# chmod 664 /etc/systemd/system/emacs.service

[root@basic ~]# which emacs
/usr/bin/emacs

2. 在文件 /etc/systemd/system/emacs.service 中 添加如下内容:
[root@basic ~]# vim /etc/systemd/system/emacs.service
[Unit]
Description=Emacs: the extensible, self-documenting text editor

[Service]
Type=forking
ExecStart=/usr/bin/emacs --daemon
ExecStop=/usr/bin/emacsclient --eval "(kill-emacs)"
Environment=SSH_AUTH_SOCK=%t/keyring/ssh
Restart=always

[Install]
WantedBy=default.target


  通过 如上的 配置, /usr/bin/emacs 可执行程序 将在 该 service start 时 以 daemon mode 模式被 启动(started).
  其中的环境变量 SSH_AUTH_SOCK 的设置中 使用了 "%t" unit specifier (其表示 运行时目录).
  如果意外退出(exits), 该 服务还会 重新启动(restarts) 该 emacs 的进程(process)


3. 执行 如下 的命令 来 reload the configuration and start the custom service:

[root@basic ~]# systemctl daemon-reload
[root@basic ~]# systemctl start emacs.service

  因为 现在 emacs editor 已经被注册(registered)为 了一个 systemd service, 所以你能够使用所有的 systemctl 命令.
  例如, 执行 systemctl status emacs 来显示(display) 该 editor 的 状态(status)
  或 执行    systemctl enable emacs  来使 该 editor 在 system boot 时 自动启动(start).

[root@basic ~]# systemctl status emacs   # 创建 emacs service unit 的状态
● emacs.service - Emacs: the extensible, self-documenting text editor
   Loaded: loaded (/etc/systemd/system/emacs.service; disabled; vendor preset: disabled)
   Active: active (running) since Sun 2019-05-12 09:12:49 CST; 28s ago
  Process: 1951 ExecStart=/usr/bin/emacs --daemon (code=exited, status=0/SUCCESS)
 Main PID: 1952 (emacs)
   CGroup: /system.slice/emacs.service
           └─1952 /usr/bin/emacs --daemon

May 12 09:12:49 basic systemd[1]: Starting Emacs: the extensible, self-documenting text editor...
May 12 09:12:49 basic emacs[1951]: ("/usr/bin/emacs")
May 12 09:12:49 basic emacs[1951]: Loading /usr/share/emacs/site-lisp/site-start.d/git-init.el (source)...
May 12 09:12:49 basic emacs[1951]: Loading /usr/share/emacs/site-lisp/site-start.d/git-init.el (source)...done
May 12 09:12:49 basic emacs[1951]: Starting Emacs daemon.
May 12 09:12:49 basic systemd[1]: Started Emacs: the extensible, self-documenting text editor.

[root@basic ~]# systemctl enable emacs  # 设置 emacs service unit 开机自启
Created symlink from /etc/systemd/system/default.target.wants/emacs.service to /etc/systemd/system/emacs.service.

---------------------------------------------------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------------------------------
Example 10.19. Creating a second instance of the sshd service (创建 sshd service 的 第二个 实例(instance))

系统管理员 通常 需要 配置 和 执行 一个 service 的 多个实例(multiple instances).
这是通过 创建 original service configuration files 的 copies 和 修改 certain parameters 来避免 与 该 service
的 primary instance 的冲突 来实现的.

如下的 procedure 演示了 如何 创建 sshd service 的 第 2 个 实例(a second instance):

1. 创建 将被用于 the second daemon 的 the sshd_config file 的 副本(copy):

[root@basic ~]# cp /etc/ssh/sshd{,-second}_config

2. 编辑 前一个步骤中 创建的 sshd-second_config file 来 为 该 second daemon 赋予一个 不同的 port number and PID file.
[root@basic ~]# vim /etc/ssh/sshd-second_config   # 修改 /etc/ssh/sshd-second_config 中的 Port 和 PidFile
Port 22220
PidFile /var/run/sshd-second.pid


通过 `man 5 sshd_config` 可查看 关于 Port 和 PidFile 选项更多的信息.
务必确保 你选择的 该 port 没有被 别的 任何 service 使用.
该 PID file 在 running the service 不是必须要存在的, 它是在 service 启动(start) 时 自动生成的.

3. 创建 该 sshd service 的 systemd unit file 的 一份 副本(copy):

[root@basic ~]# cp /usr/lib/systemd/system/sshd.service /etc/systemd/system/sshd-second.service

4. 按如下方式 修改 有 前一个步骤 创建的 sshd-second.service:
[root@basic ~]# vim /etc/systemd/system/sshd-second.service
[Unit]
# a. 修改 Description 选项:
Description=OpenSSH server second instance daemon
Documentation=man:sshd(8) man:sshd_config(5)
# b. 在 After 选项中 指定的 services中 添加 sshd.service. 因此 该 第二个实例(the second instance) 仅在第一个实例 已经启动(started) 之后 才启动(starts)
After=network.target sshd-keygen.service sshd.service
Wants=sshd-keygen.service

[Service]
Type=notify
EnvironmentFile=/etc/sysconfig/sshd
# c. The first instance of sshd includes key generation, therefore remove the ExecStartPre=/usr/sbin/sshd-keygen line.
# d. 给 sshd 添加 -f /etc/ssh/sshd-second_config 参数, 因此将使用 另外一个 configuration file.
ExecStart=/usr/sbin/sshd -D -f /etc/ssh/sshd-second_config  $OPTIONS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure
RestartSec=42s

[Install]
WantedBy=multi-user.target

5. 如果使用了 SELinux, 需要将 该 second instance 的 port 添加到 SSH ports 中, 否则, 该 sshd 的 second instance 将被拒绝 bind 到 该 port 上:
semanage port -a -t ssh_port_t -p tcp 22220

6. enable sshd-second.service, 使其在 系统 boot 时 能自动 启动(starts):

[root@basic ~]# systemctl enable sshd-second.service
Created symlink from /etc/systemd/system/multi-user.target.wants/sshd-second.service to /etc/systemd/system/sshd-second.service.



[root@basic ~]# systemctl start sshd-second.service

[root@basic ~]# systemctl status sshd-second.service  # 验证 sshd-second.service 是否 is running
● sshd-second.service - OpenSSH server second instance daemon
   Loaded: loaded (/etc/systemd/system/sshd-second.service; enabled; vendor preset: disabled)
   Active: active (running) since Sun 2019-05-12 10:28:40 CST; 3s ago
     Docs: man:sshd(8)
           man:sshd_config(5)
 Main PID: 2648 (sshd)
   CGroup: /system.slice/sshd-second.service
           └─2648 /usr/sbin/sshd -D -f /etc/ssh/sshd-second_config

May 12 10:28:40 basic systemd[1]: Starting OpenSSH server second instance daemon...
May 12 10:28:40 basic sshd[2648]: Server listening on 0.0.0.0 port 22220.
May 12 10:28:40 basic sshd[2648]: Server listening on :: port 22220.
May 12 10:28:40 basic systemd[1]: Started OpenSSH server second instance daemon.

[root@basic ~]# ssh -p 22220 root@192.168.175.141     # 验证 是否能 通过该 port 正确的 连接 到 该 service

  如果使用了 防火墙(firewall), 请务必确保 其被恰当的配置 使 connections 能被允许 连接 到 sshd 的 the second instance 上.


---------------------------------------------------------------------------------------------------------------------------
其他资源:

To learn how to properly choose a target for ordering and dependencies of your custom unit files, see the following articles::

    How to write a service unit file which enforces that particular services have to be started
    How to decide what dependencies a systemd service unit definition should have

Additional information with some real-world examples of cases triggered by the ordering and dependencies in a unit file is available in the following article:

      Is there any useful information about writing unit files?

If you want to set limits for services started by systemd, see the Red Hat Knowledgebase article

        How to set limits for services in RHEL 7 and systemd.

These limits need to be set in the service's unit file.
Note that systemd ignores limits set in the /etc/security/limits.conf and /etc/security/limits.d/*.conf configuration files.
The limits defined in these files are set by PAM when starting a login session, but daemons started by systemd do not use PAM login sessions.

---------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------
10.6.3. Converting SysV Init Scripts to Unit Files (示例: 将 SysV Init Scripts 转换 为 Unit Files)

在 花时间 将 a SysV init script 转换为 a unit file 之前, 务必确保 还没有在 任何其他地方 做过该 转换操作.
所有 redhat7 的 core services 都 自带 默认的 unit files, 且 许多 的 third-party software packages 也是如此.

  将 an init script 转换为 a unit file 需要 分析 the script 和 extracting the necessary information from it.
  Based on this data you can create a unit file as described in Section 10.6.2, “Creating Custom Unit Files”.
  As init scripts can vary greatly depending on the type of the service, you might need to employ more configuration options for translation than outlined in this chapter.
  Note that some levels of customization that were available with init scripts are no longer supported by systemd units, see Section 10.1.2, “Compatibility Changes”.


这部分内容太多, 见官网原始文档:
https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/sect-managing_services_with_systemd-unit_files#sect-Managing_Services_with_systemd-Unit_File_Convert


---------------------------------------------------------------------------------------------------------------------------


---------------------------------------------------------------------------------------------------------------------------
10.6.4. Modifying Existing Unit Files (示例: 修改 已存在 的 Unit Files)

系统(system) 安装的 services 的 默认的 unit files 被存储在 目录 /usr/lib/systemd/system/ 中.
系统管理员 不应该 直接去 修改  这些 files, 因此任何 自定义 都必须 限制在 目录 /etc/systemd/system/
下的 configuration files 中. 根据所需的变更的程度, 可以采用 如下的 方式之一:


* 在目录 /etc/systemd/system/unit.d/ 下 创建 用于存放 补充的 configuration files 的 a directory.
  该方式是多数情况下所推荐的(recommended). 其(该方式) 使用 额外的功能 扩展了 the default configuration,
  同时仍然引用 the original unit file. 因此 通过 升级 package 而 引入的 default unit 的变化(changes) 会 自动的 得到应用(applied).
  See the section called “Extending the Default Unit Configuration” for more information.


* 在 目录 /etc/systemd/system/ 下 创建 目录 /usr/lib/systemd/system/ 中 的 original unit file 的副本(copy) 并在 副本中做修改.
  因此 通过 更新 package 引入的 变化(changes) 不会被 应用(applied). 该方式对于 要 忽略 package 的更新 的 需要 持久化(persist) 的
  重要的 unit changes 很有用. See the section called “Overriding the Default Unit Configuration” for details.


为了 返回 到 unit 的 default configuration, 仅需要 删除 目录 /etc/systemd/system/ 下 自定义创建 的 configuration files.
为了 在 不 rebooting the system 的情况下 应用 unit files 的 变更(changes), 执行:

systemctl daemon-reload

daemon-reload 会 reloads all unit files and recreates the entire dependency tree, 这是 立刻 应用 a unit file 中任何变更所需要做的.
作为 替代方案, 你可以使用如下的命令 来 达到 相同的结果:

init q

同时, 如果 修改的 unit file 属于 a running service, 则该 service 必须被 重启(restarted) 来 接受 新的设置(accept new settings).

systemctl restart name.service



Important  重要!!!!!!!!!!!!!!!

  要 修改 properties, 例如 被 a SysV initscript 处理的 service 的 dependencies 或 timeouts, 不要 修改(modify) 该 initscript 本身.
  而应为该 service 创建 插入式(drop-in) 的 systemd configuration file(就如果 “Extending the Default Unit Configuration” 部分 和 “Overriding the Default Unit Configuration”
  部分所描述的那样), 然后 按 与 常规的 systemd service 相同的方式来 管理(manage) 该 service.


  例如: 要 扩展(extend) network service 的 配置, 不要修改(modify) /etc/rc.d/init.d/network initscript file.
  而应该 新创建 /etc/systemd/system/network.service.d/ 目录 和 一个 drop-in 文件 /etc/systemd/system/network.service.d/my_config.conf.
  然后, 将 修改的值(modified values) 放到 该 drop-in 文件 中.
  注意: systemd 把 network service 当做 network.service, 这也是为什么 被创建的 目录 必须 被 called network.service.d.



---------------------------------------------------------------------------------------------------------------------------

Extending the Default Unit Configuration ( 扩展 默认的 Unit 配置文件 )

要 使用 额外的 configuration options 扩展 default unit file, 首先 在目录 /etc/systemd/system/ 下 创建 配置文件 目录,
如果是 扩展 a service unit, 以 root 身份 执行如下命令:

mkdir /etc/systemd/system/name.service.d/

使用 你想 扩展的 service 的 name 替换掉 如上命令中的 name. 如上的语法 应用于 所有的 unit types.

在前一个步骤中创建的 目录下创建 a configuration file, 注意 the file name 必须以 后缀 .conf 结尾. 键入:

touch /etc/systemd/system/name.service.d/config_name.conf

使用 the configuration file 的 name 替换掉 如上命令中的 config_name. 该文件 遵守(adheres) 常规 unit file 的 结构(structure),
因此所有的 directives 必须被指定在 合适的 sections 下. see Section 10.6.1, “Understanding the Unit File Structure”.


例如: 要 add a custom dependency, 使用如下内容 创建 a configuration file:
[Unit]
Requires=new_dependency
After=new_dependency

其中 new_dependency 代表 被 标记(marked) 为 a dependency 的 unit.
另一个 例子 是 一个 restarts the service after its main process exited with a delay of 30 seconds 的配置文件:
[Service]
Restart=always
RestartSec=30


建议创建 仅聚焦于 one task 的 small configuration files. 这样的 files 能够很容易 被 移动(moved) 或 链接(linked) 到 其他 services 的 配置文件目录(configuration directories).

要应用所做的修改 到 该 unit, 以 root 身份执行:

systemctl daemon-reload
systemctl restart name.service




Example 10.20. Extending the httpd.service Configuration  (示例：扩展 httpd.service 配置文件)

要修改(modify)  httpd.service unit 是 a custom shell script 能在 Apache service 启动(starting) 时 自动被执行,
首先，创建 a directory and a custom configuration file:

[root@basic ~]# mkdir /etc/systemd/system/httpd.service.d/
[root@basic ~]# touch /etc/systemd/system/httpd.service.d/custom_script.conf


提供 你想要和 Apache 一起 被自动 start 的 文件 /usr/local/bin/custom.sh,
[root@basic ~]# vim /usr/local/bin/custom.sh
#!/bin/bash
echo "/usr/local/bin/custom.sh $(date '+%F %T')"

[root@basic ~]# chmod ug+x /usr/local/bin/custom.sh


在 custom_script.conf 文件中插入如下 text:

[root@basic ~]# vim /etc/systemd/system/httpd.service.d/custom_script.conf
[Service]
ExecStartPost=/usr/local/bin/custom.sh


要应用 该 unit changes, 执行:

[root@basic ~]# systemctl daemon-reload
[root@basic ~]# systemctl restart httpd.service

[root@basic ~]# grep -in 'custom.sh'  /var/log/messages




注意:
    目录  /etc/systemd/system/ 下 configuration directories 中 的 configuration files 的优先级 高于 目录 /usr/lib/systemd/system/ 下的 unit files.
    如果 configuration files 包含 仅能被 指定 一次(once) 的 选项, 例如 Description 或 ExecStart, 则 其 默认值(default value) 将会被覆盖.
    Note that in the output of the systemd-delta command, described in the section called “Monitoring Overriden Units”,
    such units are always marked as [EXTENDED], even though in sum, certain options are actually overridden.
---------------------------------------------------------------------------------------------------------------------------














