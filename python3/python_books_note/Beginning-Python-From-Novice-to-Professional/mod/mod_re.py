
# re

'''
    模块re提供了对正则表达式的支持。如果你听说过正则表达式，就可能知道它们有多厉害；
如果没有，就等着大吃一惊吧。

    然而，需要指出的是，要掌握正则表达式有点难。关键是每次学习一点点：只考虑完成特定
任务所需的知识。预先将所有的知识牢记在心毫无意义。本节描述模块re和正则表达式的主要功
能，让你能够快速上手。

提示 除标准文档外，Andrew Kuchling撰写的文章“Regular Expression HOWTO”（https://docs.
     python.org/3/howto/regex.html）也是很有用的Python正则表达式学习资料。


    正则表达式是什么
正则表达式是可匹配文本片段的模式。最简单的正则表达式为普通字符串，与它自己匹配。
换而言之，正则表达式'python'与字符串'python'匹配。你可使用这种匹配行为来完成如下工作：
在文本中查找模式，将特定的模式替换为计算得到的值，以及将文本分割成片段。

通配符
    正则表达式可与多个字符串匹配，你可使用特殊字符来创建这种正则表达式。例如，句点与
除换行符外的其他字符都匹配，因此正则表达式'.ython'与字符串'python'和'jython'都匹配。
它还与'qython'、'+ython'和' ython'（第一个字符为空格）等字符串匹配，但不与'cpython'、
'ython'等字符串匹配，因为句点只与一个字符匹配，而不与零或两个字符匹配。
句点与除换行符外的任何字符都匹配，因此被称为通配符（wildcard）。

对特殊字符进行转义
    普通字符只与自己匹配，但特殊字符的情况完全不同。例如，假设要匹配字符串
'python.org'，可以直接使用模式'python.org'吗？可以，但它也与'pythonzorg'匹配（还记得吗？
句点与除换行符外的其他字符都匹配），这可能不是你想要的结果。要让特殊字符的行为与普通
字符一样，可对其进行转义：像第1章对字符串中的引号进行转义时所做的那样，在它前面加上
一个反斜杠。因此，在这个示例中，可使用模式'python\\.org'，它只与'python.org'匹配。

    请注意，为表示模块re要求的单个反斜杠，需要在字符串中书写两个反斜杠，让解释器对其
进行转义。换而言之，这里包含两层转义：解释器执行的转义和模块re执行的转义。实际上，在
有些情况下也可使用单个反斜杠，让解释器自动对其进行转义，但请不要这样依赖解释器。如果
你厌烦了两个反斜杆，可使用原始字符串，如r'python\.org'。

字符集
匹配任何字符很有用，但有时你需要更细致地控制。为此，可以用方括号将一个子串括起，
创建一个所谓的字符集。这样的字符集与其包含的字符都匹配，例如'[pj]ython'与'python'和
'jython'都匹配，但不与其他字符串匹配。你还可使用范围，例如'[a-z]'与a~z的任何字母都匹
配。你还可组合多个访问，方法是依次列出它们，例如'[a-zA-Z0-9]'与大写字母、小写字母和
数字都匹配。请注意，字符集只能匹配一个字符。

    要指定排除字符集，可在开头添加一个^字符，例如'[^abc]'与除a、b和c外的其他任何字符
都匹配。


字符集中的特殊字符
    一般而言，对于诸如句点、星号和问号等特殊字符，要在模式中将其用作字面字符而不
是正则表达式运算符，必须使用反斜杠对其进行转义。在字符集中，通常无需对这些字符进
行转义，但进行转义也是完全合法的。然而，你应牢记如下规则。

    脱字符（^）位于字符集开头时，除非要将其用作排除运算符，否则必须对其进行转
义。换而言之，除非有意为之，否则不要将其放在字符集开头。
    同样，对于右方括号（]）和连字符（-），要么将其放在字符集开头，要么使用反斜
杠对其进行转义。实际上，如果你愿意，也可将连字符放在字符集末尾。


二选一和子模式
    需要以不同的方式处理每个字符时，字符集很好，但如果只想匹配字符串'python'和'perl'，
该如何办呢？使用字符集或通配符无法指定这样的模式，而必须使用表示二选一的特殊字符：管
道字符（|）。所需的模式为'python|perl'。
    然而，有时候你不想将二选一运算符用于整个模式，而只想将其用于模式的一部分。为此，
可将这部分（子模式）放在圆括号内。对于前面的示例，可重写为'p(ython|erl)'。请注意，单
个字符也可称为子模式。

可选模式和重复模式
    通过在子模式后面加上问号，可将其指定为可选的，即可包含可不包含。例如，下面这个不
太好懂的模式：
    r'(http://)?(www\.)?python\.org'

只与下面这些字符串匹配：
    'http://www.python.org'
    'http://python.org'
    'www.python.org'
    'python.org'


对于这个示例，需要注意如下几点。
对于这个示例，需要注意如下几点。
      我对句点进行了转义，以防它充当通配符。
      为减少所需的反斜杠数量，我使用了原始字符串。
      每个可选的子模式都放在圆括号内。
      每个可选的子模式都可以出现，也可以不出现。
    问号表示可选的子模式可出现一次，也可不出现。还有其他几个运算符用于表示子模式可重
复多次。

      (pattern)*：pattern可重复0、1或多次。
      (pattern)+：pattern可重复1或多次。
      (pattern){m,n}：模式可从父m~n次。

例如，r'w*\.python\.org'与'www.python.org'匹配，也与'.python.org'、'ww.python.org'
和'wwwwwww.python.org'匹配。同样，r'w+\.python\.org'与'w.python.org'匹配，但与'.python.
org'不匹配，而r'w{3,4}\.python\.org'只与'www.python.org'和'wwww.python.org'匹配。

注意 在这里，术语匹配指的是与整个字符串匹配，而函数match（参见表10-9）只要求模式与
     字符串开头匹配。


字符串的开头和末尾
    到目前为止，讨论的都是模式是否与整个字符串匹配，但也可查找与模式匹配的子串，如字
符串'www.python.org'中的子串'www'与模式'w+'匹配。像这样查找字符串时，有时在整个字符串
开头或末尾查找很有用。例如，你可能想确定字符串的开头是否与模式'ht+p'匹配，为此可使用
脱字符（'^'）来指出这一点。例如，'^ht+p'与'http://python.org'和'htttttp://python.org'
匹配，但与'www.http.org'不匹配。同样，要指定字符串末尾，可使用美元符号（$）。

注意 完整的正则表达式运算符清单请参阅Python库中的Regular Expression Syntax部分。

'''


# 模块re的内容
'''
模块re包含多个使用正则表达
式的函数，表10-9描述了其中最重要的一些。

        表10-9 模块re中一些重要的函数

   函 数                                           描 述
compile(pattern[, flags])                 根据包含正则表达式的字符串创建模式对象
search(pattern, string[, flags])          在字符串中查找模式
match(pattern, string[, flags])           在字符串开头匹配模式
split(pattern, string[, maxsplit=0])      根据模式来分割字符串
findall(pattern, string)                  返回一个列表，其中包含字符串中所有与模式匹配的子串
sub(pat, repl, string[, count=0])         将字符串中与模式pat匹配的子串都替换为repl
escape(string)                            对字符串中所有的正则表达式特殊字符都进行转义


    函数re.compile将用字符串表示的正则表达式转换为模式对象，以提高匹配效率。调用
search、match等函数时，如果提供的是用字符串表示的正则表达式，都必须在内部将它们转换
为模式对象。通过使用函数compile对正则表达式进行转换后，每次使用它时都无需再进行转换。
模式对象也有搜索/匹配方法，因此re.search(pat, string)（其中pat是一个使用字符串表示的正
则表达式）等价于pat.search(string)（其中pat是使用compile创建的模式对象）。编译后的正则
表达式对象也可用于模块re中的普通函数中。

    函数re.search在给定字符串中查找第一个与指定正则表达式匹配的子串。如果找到这样的
子串，将返回MatchObject（结果为真），否则返回None（结果为假）。鉴于返回值的这种特征，可
在条件语句中使用这个函数，如下所示：
'''
if re.search(pat, string):
    print('Found it!')

'''
    然而，如果你需要获悉有关匹配的子串的详细信息，可查看返回的MatchObject。下一节将
更详细地介绍MatchObject。

    函数re.match尝试在给定字符串开头查找与正则表达式匹配的子串，因此re.match('p',
'python')返回真（MatchObject），而re.match('p', 'www.python.org')返回假（None）。

注意    函数match在模式与字符串开头匹配时就返回True，而不要求模式与整个字符串匹配。如
        果要求与整个字符串匹配，需要在模式末尾加上一个美元符号。美元符号要求与字符串
        末尾匹配，从而将匹配检查延伸到整个字符串。

    函数re.split根据与模式匹配的子串来分割字符串。这类似于字符串方法split，但使用正
则表达式来指定分隔符，而不是指定固定的分隔符。例如，使用字符串方法split时，可以字符
串', '为分隔符来分割字符串，但使用re. split时，可以空格和逗号为分隔符来分割字符串。

>>> some_text = 'alpha, beta,,,,gamma delta'
>>> re.split('[, ]+', some_text)
['alpha', 'beta', 'gamma', 'delta']

注意 如果模式包含圆括号，将在分割得到的子串之间插入括号中的内容。例如，re.split('o(o)',
    'foobar')的结果为['f', 'o', 'bar']。

从这个示例可知，返回值为子串列表。参数maxsplit指定最多分割多少次。
>>> re.split('[, ]+', some_text, maxsplit=2)
['alpha', 'beta', 'gamma delta']
>>> re.split('[, ]+', some_text, maxsplit=1)
['alpha', 'beta,,,,gamma delta']

函数re.findall返回一个列表，其中包含所有与给定模式匹配的子串。例如，要找出字符串
包含的所有单词，可像下面这样做：

>>> pat = '[a-zA-Z]+'
>>> text = '"Hm... Err -- are you sure?" he said, sounding insecure.'
>>> re.findall(pat, text)
['Hm', 'Err', 'are', 'you', 'sure', 'he', 'said', 'sounding', 'insecure']

要查找所有的标点符号，可像下面这样做：
>>> pat = r'[.?\-",]+'
>>> re.findall(pat, text)
['"', '...', '--', '?"', ',', '.']

请注意，这里对连字符（-）进行了转义，因此Python不会认为它是用来指定字符范围的（如a-z）。

函数re.sub从左往右将与模式匹配的子串替换为指定内容。请看下面的示例：
>>> pat = '{name}'
>>> text = 'Dear {name}...'
>>> re.sub(pat, 'Mr. Gumby', text)
'Dear Mr. Gumby...'

有关如何更有效地使用这个函数，请参阅随后的一节。
    re.escape是一个工具函数，用于对字符串中所有可能被视为正则表达式运算符的字符进行
转义。使用这个函数的情况有：字符串很长，其中包含大量特殊字符，而你不想输入大量的反斜
杠；你从用户那里获取了一个字符串（例如，通过函数input），想将其用于正则表达式中。下面
的示例说明了这个函数的工作原理：
>>> re.escape('www.python.org')
'www\\.python\\.org'
>>> re.escape('But where is the ambiguity?')
'But\\ where\\ is\\ the\\ ambiguity\\?'

    注意在表10-9中，注意到有些函数接受一个名为flags的可选参数。这个参数可用于修改正则
表达式的解读方式。有关这方面的详细信息，请参阅“Python库参考手册”中讨论模块
re的部分。


# 匹配对象和编组
    在模块re中，查找与模式匹配的子串的函数都在找到时返回MatchObject对象。这种对象包
含与模式匹配的子串的信息，还包含模式的哪部分与子串的哪部分匹配的信息。这些子串部分称
为编组（group）。
    编组就是放在圆括号内的子模式，它们是根据左边的括号数编号的，其中编组0指的是整个
模式。因此，在下面的模式中：

'There (was a (wee) (cooper)) who (lived in Fyfe)'

包含如下编组：
    0 There was a wee cooper who lived in Fyfe
    1 was a wee cooper
    2 wee
    3 cooper
    4 lived in Fyfe

通常，编组包含诸如通配符和重复运算符等特殊字符，因此你可能想知道与给定编组匹配的
内容。例如，在下面的模式中：
    r'www\.(.+)\.com$'

    编组0包含整个字符串，而编组1包含'www.'和'.com'之间的内容。通过创建类似于这样的模
式，可提取字符串中你感兴趣的部分。
表10-10描述了re匹配对象的一些重要方法。

                    表10-10 re匹配对象的重要方法

方 法                       描 述
group([group1, ...])      获取与给定子模式（编组）匹配的子串
start([group])            返回与给定编组匹配的子串的起始位置
end([group])              返回与给定编组匹配的子串的终止位置（与切片一样，不包含终止位置）
span([group])             返回与给定编组匹配的子串的起始和终止位置

    方法group返回与模式中给定编组匹配的子串。如果没有指定编组号，则默认为0。如果只指
定了一个编组号（或使用默认值0），将只返回一个字符串；否则返回一个元组，其中包含与给定
编组匹配的子串。

注意    除整个模式（编组0）外，最多还可以有99个编组，编号为1~99。
    方法start返回与给定编组（默认为0，即整个模式）匹配的子串的起始索引。
    方法end类似于start，但返回终止索引加1
    方法span返回一个元组，其中包含与给定编组（默认为0，即整个模式）匹配的子串的起始
索引和终止索引。

下面的示例说明了这些方法的工作原理：
>>> m = re.match(r'www\.(.*)\..{3}', 'www.python.org')
>>> m.group(1)
'python'
>>> m.start(1)
4
>>> m.end(1)
10
>>> m.span(1)
(4, 10)


'''

# 替换中的组号和函数
"""
    在第一个re.sub使用示例中，我只是将一个子串替换为另一个。这也可使用字符串方法
replace（参见3.4节）轻松地完成。当然，正则表达式很有用，因为它们让你能够以更灵活的方
式进行搜索，还让你能够执行更复杂的替换。
    为利用re.sub的强大功能，最简单的方式是在替代字符串中使用组号。在替换字符串中，任
何类似于'\\n'的转义序列都将被替换为与模式中编组n匹配的字符串。例如，假设要将
'*something*'替换为'<em>something</em>'，其中前者是在纯文本文档（如电子邮件）中表示突
出的普通方式，而后者是相应的HTML代码（用于网页中）。下面先来创建一个正则表达式。
    >>> emphasis_pattern = r'\*([^\*]+)\*'

    请注意，正则表达式容易变得难以理解，因此为方便其他人（也包括你自己）以后阅读代码，
使用有意义的变量名很重要。

提示
        要让正则表达式更容易理解，一种办法是在调用模块re中的函数时使用标志VERBOSE。这
    让你能够在模式中添加空白（空格、制表符、换行符等），而re将忽略它们——除非将它
    放在字符类中或使用反斜杠对其进行转义。在这样的正则表达式中，你还可添加注释。
    下述代码创建的模式对象与emphasis_pattern等价，但使用了VERBOSE标志：
    >>> emphasis_pattern = re.compile(r'''
    ... \* # 起始突出标志——一个星号
    ... ( # 与要突出的内容匹配的编组的起始位置
    ... [^\*]+ # 与除星号外的其他字符都匹配
    ... ) # 编组到此结束
    ... \* # 结束突出标志
    ... ''', re.VERBOSE)
    ...

创建模式后，就可使用re.sub来完成所需的替换了。
>>> re.sub(emphasis_pattern, r'<em>\1</em>', 'Hello, *world*!')
'Hello, <em>world</em>!'

    如你所见，成功地将纯文本转换成了HTML代码。
    然而，通过将函数用作替换内容，可执行更复杂的替换。这个函数将MatchObject作为唯一
的参数，它返回的字符串将用作替换内容。换而言之，你可以对匹配的字符串做任何处理，并通
过细致的处理来生成替换内容。你可能会问，这有何用途呢？等你开始尝试使用正则表达式后，
将发现这种机制的用途非常多，随后会介绍其中的一个。


贪婪和非贪婪模式   greedy and lazy

重复运算符默认是贪婪的，这意味着它们将匹配尽可能多的内容。例如，假设重写了
前面的突出程序，在其中使用了如下模式：
    >>> emphasis_pattern = r'\*(.+)\*'

这个模式与以星号打头和结尾的内容匹配。好像很完美，不是吗？但情况并非如此。

    >>> re.sub(emphasis_pattern, r'<em>\1</em>', '*This* is *it*!')
    '<em>This* is *it</em>!'

    如你所见，这个模式匹配了从第一个星号到最后一个星号的全部内容，其中包含另外
两个星号！这就是贪婪的意思：能匹配多少就匹配多少。

    在这里，你想要的显然不是这种过度贪婪的行为。在你知道不应将某个特定的字符包
含在内时，本章前面的解决方案（使用一个匹配任何非星号字符的字符集）很好。下面再
来看另一个场景：如果使用'**something**'来表示突出呢？在这种情形下，在要强调的内
容中包含单个星号不是问题，但如何避免过度贪婪呢？

    这实际上很容易，只需使用重复运算符的非贪婪版即可。对于所有的重复运算符，都
可在后面加上问号来将其指定为非贪婪的。
    >>> emphasis_pattern = r'\*\*(.+?)\*\*'
    >>> re.sub(emphasis_pattern, r'<em>\1</em>', '**This** is **it**!')
    '<em>This</em> is <em>it</em>!'

    这里使用的是运算符+?而不是+。这意味着与以前一样，这个模式将匹配一个或多个通配
符，但匹配尽可能少的内容，因为它是非贪婪的。因此，这个模式只匹配到下一个'\*\*'，
即它末尾的内容。如你所见，效果很好。


"""

# 其他有趣的标准模块
'''
     argparse：在UNIX中，运行命令行程序时常常需要指定各种选项（开关），Python解释器
就是这样的典范。这些选项都包含在sys.argv中，但要正确地处理它们绝非容易。模块
argparse使得提供功能齐备的命令行界面易如反掌。
     cmd：这个模块让你能够编写类似于Python交互式解释器的命令行解释器。你可定义命令，
让用户能够在提示符下执行它们。或许可使用这个模块为你编写的程序提供用户界面？
    csv：CSV指的是逗号分隔的值（comma-seperated values），很多应用程序（如很多电子表
格程序和数据库程序）都使用这种简单格式来存储表格数据。这种格式主要用于在不同
的程序之间交换数据。模块csv让你能够轻松地读写CSV文件，它还以非常透明的方式处
理CSV格式的一些棘手部分。
     datetime：如果模块time不能满足你的时间跟踪需求，模块datetime很可能能够满足。
datetime支持特殊的日期和时间对象，并让你能够以各种方式创建和合并这些对象。相比
于模块time，模块datetime的接口在很多方面都更加直观。
     difflib：这个库让你能够确定两个序列的相似程度，还让你能够从很多序列中找出与指
定序列最为相似的序列。例如，可使用difflib来创建简单的搜索程序。
     enum：枚举类型是一种只有少数几个可能取值的类型。很多语言都内置了这样的类型，如
果你在使用Python时需要这样的类型，模块enum可提供极大的帮助。
     functools：这个模块提供的功能是，让你能够在调用函数时只提供部分参数（部分求值，
partial evaluation），以后再填充其他的参数。在Python 3.0中，这个模块包含filter和reduce。
     hashlib：使用这个模块可计算字符串的小型“签名”（数）。计算两个不同字符串的签名
时，几乎可以肯定得到的两个签名是不同的。你可使用它来计算大型文本文件的签名，
这个模块在加密和安全领域有很多用途①。
     itertools：包含大量用于创建和合并迭代器（或其他可迭代对象）的工具，其中包括可
以串接可迭代对象、创建返回无限连续整数的迭代器（类似于range，但没有上限）、反复
遍历可迭代对象以及具有其他作用的函数。
     logging：使用print语句来确定程序中发生的情况很有用。要避免跟踪时出现大量调试输
出，可将这些信息写入日志文件中。这个模块提供了一系列标准工具，可用于管理一个
或多个中央日志，它还支持多种优先级不同的日志消息。
     statistics：计算一组数的平均值并不那么难，但是要正确地获得中位数，以确定总体标
准偏差和样本标准偏差之间的差别，即便对于偶数个元素来说，也需要费点心思。在这
种情况下，不要手工计算，而应使用模块statistics！
     timeit、profile和trace：模块timeit（和配套的命令行脚本）是一个测量代码段执行时
间的工具。这个模块暗藏玄机，度量性能时你可能应该使用它而不是模块time。模块
profile（和配套模块pstats）可用于对代码段的效率进行更全面的分析。模块trace可帮
助你进行覆盖率分析（即代码的哪些部分执行了，哪些部分没有执行），这在编写测试代
码时很有用。

'''





















