
# 集合、堆和双端队列
'''
    有用的数据结构有很多。Python支持一些较常用的，其中的字典（散列表）和列表（动态数
组）是Python语言的有机组成部分。还有一些虽然不那么重要，但有时也能派上用场。
'''

# 集合 set
'''
很久以前，集合是由模块sets中的Set类实现的。虽然在既有代码中可能遇到Set实例，但除
非要向后兼容，否则真的没有理由再使用它。在较新的版本中，集合是由内置类set实现的，这
意味着你可直接创建集合，而无需导入模块sets。

>>> set(range(10))
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

    可使用序列（或其他可迭代对象）来创建集合，也可使用花括号显式地指定。请注意，不能
仅使用花括号来创建空集合(emtpy set)，因为这将创建一个空字典(empty dict)。
>>> type({})    # empty dict
<class 'dict'>

    相反，必须在不提供任何参数的情况下调用set。集合主要用于成员资格检查，因此将忽略
重复的元素：

>>> {0, 1, 2, 3, 0, 1, 2, 3, 4, 5}
{0, 1, 2, 3, 4, 5}

与字典一样，集合中元素的排列顺序是不确定的，因此不能依赖于这一点。
>>> {'fee', 'fie', 'foe'}
{'foe', 'fee', 'fie'}

    除成员资格检查外，还可执行各种标准集合操作（你可能在数学课上学过），如并集和交集，
为此可使用对整数执行按位操作的运算符（参见附录B）。例如，要计算两个集合的并集，可对其
中一个集合调用方法union，也可使用按位或运算符|。

>>> a = {1, 2, 3}
>>> b = {2, 3, 4}
>>> a.union(b)
{1, 2, 3, 4}
>>> a | b
{1, 2, 3, 4}


还有其他一些方法和对应的运算符，这些方法的名称清楚地指出了其功能：
>>> c = a & b
>>> c.issubset(a)
True
>>> c <= a
True
>>> c.issuperset(a)
False
>>> c >= a
False
>>> a.intersection(b)
{2, 3}
>>> a & b
{2, 3}
>>> a.difference(b)
{1}
>>> a - b
{1}
>>> a.symmetric_difference(b)
{1, 4}
>>> a ^ b
{1, 4}
>>> a.copy()
{1, 2, 3}
>>> a.copy() is a
False


    另外，还有对应于各种就地操作的方法以及基本方法add和remove。有关这些方法的详细信
息，请参阅“Python库参考手册”中讨论集合类型的部分。
'''


'''
提示   需要计算两个集合的并集的函数时，可使用set中方法union的未关联版本。这可能很有
       用，如与reduce一起使用。

>>> my_sets = []
>>> for i in range(10):
...     my_sets.append(set(range(i, i+5)))
...
>>> reduce(set.union, my_sets)
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}

'''

'''
集合是可变的，因此不能用作字典中的键。另一个问题是，集合只能包含不可变（可散列）
的值，因此不能包含其他集合。由于在现实世界中经常会遇到集合的集合，因此这可能是个问题。
所幸还有frozenset类型，它表示不可变（可散列）的集合。

>>> a = set()
>>> b = set()
>>> a.add(b)
Traceback (most recent call last):
 File "<stdin>", line 1, in ?
TypeError: set objects are unhashable
>>> a.add(frozenset(b))

    构造函数frozenset创建给定集合的副本。在需要将集合作为另一个集合的成员或字典中的
键时，frozenset很有用。
'''



























