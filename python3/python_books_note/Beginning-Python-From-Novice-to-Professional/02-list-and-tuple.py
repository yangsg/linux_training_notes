
'''
在Python中，最基本的数据结构为序列（sequence）。
序列中的每个元素都有编号，即其位置或索引，其中第一个元素的索引为0，第二个元素的索引
为1，依此类推。在有些编程语言中，从1开始给序列中的元素编号，但从0开始指出相对于序列
开头的偏移量。这显得更自然，同时可回绕到序列末尾，用负索引表示序列末尾元素的位置
'''

# 列表和元组的主要不同在于，列表是可以修改的，而元组不可以

edward = ['Edward Gumby', 42]
john = ['John Smith', 50]
database = [edward, john]
database  # [['Edward Gumby', 42], ['John Smith', 50]]

'''
注意 Python支持一种数据结构的基本概念，名为容器（container）。容器基本上就是可包含其
他对象的对象。

两种主要的容器是序列（如列表和元组）和映射（如字典）

有一种既不是序列也不是映射的容器，它就是集合（set）
'''

'''
通用的序列操作
有几种操作适用于所有序列，包括索引、切片、相加、相乘和成员资格检查。另外，Python
还提供了一些内置函数，可用于确定序列的长度以及找出序列中最大和最小的元素。
'''
greeting = 'Hello'
greeting[0]       # 'H'

'''
当你使
用负数索引时，Python将从右（即从最后一个元素）开始往左数，因此1是最后一个元素的位置。
'''
greeting[-1]  # 'o'

'''
对于字符串字面量（以及其他的序列字面量），可直接对其执行索引操作，无需先将其赋给
变量。这与先赋给变量再对变量执行索引操作的效果是一样的。
'''
'Hello'[1]


#切片
tag = '<a href="http://www.python.org">Python web site</a>'
tag[9:30]  # 'http://www.python.org'
tag[32:-4] # 'Python web site'

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
numbers[3:6] # [4, 5, 6]
numbers[0:1] # [1]


# 绝妙的简写
# 访问前述数字列表中的最后三个元素
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
numbers[7:10] # [8, 9, 10]
numbers[-3:]  # [8, 9, 10]

# 如果切片始于序列开头，可省略第一个索引。
numbers[:3] # [1, 2, 3]

# 要复制整个序列，可将两个索引都省略。
numbers[:] # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# 更大的步长
numbers[0:10:1]  # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
numbers[0:10:2]  # [1, 3, 5, 7, 9]
numbers[3:6:3]   # [4]

# 显式地指定步长时，也可使用前述简写
numbers[::4] # [1, 5, 9]

# 当然，步长不能为0，否则无法向前移动，但可以为负数，即从右向左提取元素
numbers[8:3:-1]  # [9, 8, 7, 6, 5]
numbers[10:0:-2] # [10, 8, 6, 4, 2]
numbers[0:10:-2] # []
numbers[::-2]    # [10, 8, 6, 4, 2]
numbers[5::-2]   # [6, 4, 2]
'''
当你
省略起始和结束索引时，Python竟然执行了正确的操作：步长为正数时，它从起点移到终点，而
步长为负数时，它从终点移到起点。
'''
numbers[:5:-2]  # [10, 8]

# 序列相加
[1, 2, 3] + [4, 5, 6] # [1, 2, 3, 4, 5, 6]
'Hello,' + 'world!'   # 'Hello,world!'

'''
>>> [1, 2, 3] + 'world!'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can only concatenate list (not "str") to list

从错误消息可知，不能拼接列表和字符串，虽然它们都是序列。一般而言，不能拼接不同类
型的序列。
'''


# 乘法

# 将序列与数x相乘时，将重复这个序列x次来创建一个新序列：
'python' * 5 # 'pythonpythonpythonpythonpython'
[42] * 10    # [42, 42, 42, 42, 42, 42, 42, 42, 42, 42]

# None、空列表和初始化
[]  # 空列表是使用不包含任何内容的两个方括号（[]）表示的

'''
果要创建一个可包含10个元素
的列表，但没有任何有用的内容，可像前面那样使用[42]*10。但更准确的做法是使用[0]*10，
这将创建一个包含10个零的列表
[42] * 10    # [42, 42, 42, 42, 42, 42, 42, 42, 42, 42]
[0] * 10     # [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
'''

'''
然而，在有些情况下，你可能想使用表示“什么都没有”的值，
如表示还没有在列表中添加任何内容。在这种情况下，可使用None。在Python中，None表示什么
都没有。因此，要将列表的长度初始化为10，可像下面这样做：
'''
[None] * 10  # [None, None, None, None, None, None, None, None, None, None]

# 成员资格
# 要检查特定的值是否包含在序列中，可使用运算符in

permissions = 'rw'
'w' in permissions  # True
'x' in permissions  # False

'''
>>> users = ['mlh', 'foo', 'bar']
>>> input('Enter your user name: ') in users
Enter your user name: mlh
True
>>> subject = '$$$ Get rich now!!! $$$'
>>> '$$$' in subject
True

最后一个示例检查字符串变量subject是否包含字符串'$$$'，这
可用于垃圾邮件过滤器中。

注意
相比于其他示例，检查字符串是否包含'$$$'的示例稍有不同。一般而言，运算符in检查
指定的对象是否是序列（或其他集合）的成员（即其中的一个元素），但对字符串来说，
只有它包含的字符才是其成员或元素，因此下面的代码完全合理：
>>> 'P' in 'Python'
True

事实上，在较早的Python版本中，只能对字符串执行这种成员资格检查——确定指定的
字符是否包含在字符串中，但现在可使用运算符in来检查指定的字符串是否为另一个字
符串的子串
'''

# 长度、最小值和最大值
'''
内置函数len、min和max很有用，其中函数len返回序列包含的元素个数，而min和max分别返
回序列中最小和最大的元素
'''
numbers = [100, 34, 678]
len(numbers) # 3
max(numbers) # 678
min(numbers) # 34

max(2, 3)       # 3
min(9, 3, 2, 5) # 2
'''
基于前面的解释，这些代码应该很容易理解，但最后两个表达式可能例外。在这两个表达式
中，调用max和min时指定的实参并不是序列，而直接将数作为实参。
'''


# 列表：Python 的主力
# 列表是可变的，即可修改其内容。另外，列表有很多特有的方法。

'''
函数list
鉴于不能像修改列表那样修改字符串，因此在有些情况下使用字符串来创建列表很有帮助。
为此，可使用函数list。(注：list实际上是一个类，而不是函数)
'''
list('Hello') # ['H', 'e', 'l', 'l', 'o']  # 请注意，可将任何序列（而不仅仅是字符串）作为list的参数。

'''
提示 要将字符列表（如前述代码中的字符列表）转换为字符串，可使用下面的表达式：
''.join(somelist)
其中somelist是要转换的列表。
'''
''.join(['H', 'e', 'l', 'l', 'o'])   # 'Hello'


# 基本的列表操作

'''
修改列表：给元素赋值
>>> x = [1, 1, 1]
>>> x[1] = 2
>>> x
[1, 2, 1]

注意 不能给不存在的元素赋值
'''

# 删除元素
names = ['Alice', 'Beth', 'Cecil', 'Dee-Dee', 'Earl']
del names[2] # 可使用 del 语句删除列表元素
names        # ['Alice', 'Beth', 'Dee-Dee', 'Earl']
'''
除用于删除列表元素外，del语句还
可用于删除其他东西。你可将其用于字典（参见第4章）乃至变量
'''

# 给切片赋值
# 切片是一项极其强大的功能，而能够给切片赋值让这项功能显得更加强大。
name = list('Perl')
name   # ['P', 'e', 'r', 'l']
name[2:] = list('ar')  #给切片赋值
name   # ['P', 'e', 'a', 'r']

'''
从上述代码可知，可同时给多个元素赋值。你可能认为，这有什么大不了的，分别给每个元
素赋值不是一样的吗？确实如此，但通过使用切片赋值，可将切片替换为长度与其不同的序列。
'''
name = list('Perl')
name[1:] = list('ython')   # 将切片替换为长度与其不同的序列
name   # ['P', 'y', 't', 'h', 'o', 'n']

# 使用切片赋值还可在不替换原有元素的情况下插入新元素
numbers = [1, 5]
numbers[1:1] = [2, 3, 4]  # 插入新元素 #在这里，我“替换”了一个空切片，相当于插入了一个序列。你可采取相反的措施来删除切片
numbers # [1, 2, 3, 4, 5]
numbers[1:4] = []  # 删除切片, 改行代码与 与 del numbers[1:4] 等效。现在，你可自己尝试执行步长不为1（乃至为负）的切片赋值了
numbers  # [1, 5]

# 列表方法

# append
lst = [1, 2, 3]
lst.append(4)  # 方法append用于将一个对象附加到列表末, append也就地修改列表。这意味着它不会返回修改后的新列表，而是直接修改旧列表。
lst            # [1, 2, 3, 4]

# clear
lst = [1, 2, 3]
lst.clear()  # 方法clear就地清空列表的内容。这类似于切片赋值语句lst[:] = []
lst   # []

# copy
'''
方法copy 复制列表。前面说过，常规复制只是将另一个名称关联到列表。
>>> a = [1, 2, 3]
>>> b = a
>>> b[1] = 4
>>> a
[1, 4, 3]

要让a和b指向不同的列表，就必须将b关联到a的副本
'''
a = [1, 2, 3]
b = a.copy()  # b 指向了 a 的副本。这类似于使用a[:]或list(a)，它们也都复制a
b[1] = 4
a # [1, 2, 3]
b # [1, 4, 3]


# count
['to', 'be', 'or', 'not', 'to', 'be'].count('to') # 2 #方法count计算指定的元素在列表中出现了多少次
x = [[1, 2], 1, 1, [2, 1, [1, 2]]]
x.count(1)      # 2
x.count([1, 2]) # 1

# extend
'''
方法extend让你能够同时将多个值附加到列表末尾，为此可将这些值组成的序列作为参数提
供给方法extend。换而言之，你可使用一个列表来扩展另一个列表
'''
a = [1, 2, 3]
b = [4, 5, 6]
a.extend(b)
a  # [1, 2, 3, 4, 5, 6]

'''
这可能看起来类似于拼接，但存在一个重要差别，那就是将修改被扩展的序列（这里是a）。
在常规拼接中，情况是返回一个全新的序列。
'''
a = [1, 2, 3]
b = [4, 5, 6]
a + b  # [1, 2, 3, 4, 5, 6]
a # [1, 2, 3]

'''
如你所见，拼接出来的列表与前一个示例扩展得到的列表完全相同，但在这里a并没有被修
改。鉴于常规拼接必须使用a和b的副本创建一个新列表，因此如果你要获得类似于下面的效果，
拼接的效率将比extend低：
a = a + b
另外，拼接操作并非就地执行的，即它不会修改原来的列表。要获得与extend相同的效果，
可将列表赋给切片，如下所示：
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> a[len(a):] = b  # 这虽然可行，但可读性不是很高
>>> a
[1, 2, 3, 4, 5, 6]
'''

# index
knights = ['We', 'are', 'the', 'knights', 'who', 'say', 'ni']
knights.index('who') # 4  # 方法index在列表中查找指定值第一次出现的索引
knights.index('herring')      # 然而，搜索'herring'时引发了异常，因为根本就没有找到这个单词
'''
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: 'herring' is not in list
'''
knights[4] # 'who'


# insert
numbers = [1, 2, 3, 5, 6, 7]
numbers.insert(3, 'four')
numbers   # [1, 2, 3, 'four', 5, 6, 7]

numbers = [1, 2, 3, 5, 6, 7]
numbers[3:3] = ['four']  #与extend一样，也可使用切片赋值来获得与insert一样的效果, 这虽巧妙，但可读性根本无法与使用insert媲美
numbers # [1, 2, 3, 'four', 5, 6, 7]


# pop
'''
>>> x = [1, 2, 3]
>>> x.pop()  # 方法pop从列表中删除一个元素（末尾为最后一个元素），并返回这一元素. 注意pop是唯一既修改列表又返回一个非None值的列表方法。
3
>>> x
[1, 2]
>>> x.pop(0)
1
'''

'''
使用pop可实现一种常见的数据结构——栈（stack）。栈就像一叠盘子，你可在上面添加盘子，
还可从上面取走盘子。最后加入的盘子最先取走，这被为后进先出（LIFO）


push和pop是大家普遍接受的两种栈操作（加入和取走）的名称。Python没有提供push，但可
使用append来替代。方法pop和append的效果相反，因此将刚弹出的值压入（或附加）后，得到的
栈将与原来相同。
>>> x = [1, 2, 3]
>>> x.append(x.pop())
>>> x
[1, 2, 3]

提示
要创建先进先出（FIFO）的队列，可使用insert(0, ...)代替append。另外，也可继续使
用append，但用pop(0)替代pop()。一种更佳的解决方案是，使用模块collections中的
deque

'''

# remove
x = ['to', 'be', 'or', 'not', 'to', 'be']
x.remove('be')   # 方法remove用于删除第一个为指定值的元素. 如你所见，这只删除了为指定值的第一个元素，无法删除列表中其他为指定值的元素（这里是字符串'bee'）。
x # ['to', 'or', 'not', 'to', 'be']
x.remove('bee')
'''
Traceback (innermost last):
File "<pyshell>", line 1, in ?
x.remove('bee')
ValueError: list.remove(x): x not in list

请注意，remove是就地修改且不返回值的方法之一。不同于pop的是，它修改列表，但不返
回任何值。
'''

# reverse
x = [1, 2, 3]
x.reverse()  #方法reverse按相反的顺序排列列表中的元素. 注意到reverse修改列表，但不返回任何值（与remove和sort等方法一样）
x # [3, 2, 1]
# 如果要按相反的顺序迭代序列，可使用函数reversed。这个函数不返回列表，而是返回
# 一个迭代器（迭代器将在第9章详细介绍）。你可使用list将返回的对象转换为列表。
x = [1, 2, 3]
list(reversed(x)) # reversed 不返回列表，而是返回一个迭代器. 这也是迭代器设计模式的一个使用案例
[3, 2, 1]

# sort
x = [4, 6, 2, 1, 7, 9]
x.sort()  # 方法sort用于对列表就地排序。就地排序意味着对原来的列表进行修改，使其元素按顺序排列，而不是返回排序后的列表的副本
x # [1, 2, 4, 6, 7, 9]

'''
前面介绍了多个修改列表而不返回任何值的方法，在大多数情况下，这种行为都相当自然（例
如，对append来说就如此）。需要强调sort的行为也是这样的，因为这种行为给很多人都带来了
困惑。在需要排序后的列表副本并保留原始列表不变时，通常会遭遇这种困惑。为实现这种目标，
一种直观（但错误）的方式是像下面这样做：
>>> x = [4, 6, 2, 1, 7, 9]
>>> y = x.sort() # Don't do this! # error  error error error error error error error error error !!!!!!!!!!!
>>> print(y)
None

鉴于sort修改x且不返回任何值，最终的结果是x是经过排序的，而y包含None。为实现前述
目标，正确的方式之一是先将y关联到x的副本，再对y进行排序，如下所示：
>>> x = [4, 6, 2, 1, 7, 9]
>>> y = x.copy()
>>> y.sort()
>>> x
[4, 6, 2, 1, 7, 9]
>>> y
[1, 2, 4, 6, 7, 9]

为获取排序后的列表的副本，
另一种方式是使用函数sorted。
'''
x = [4, 6, 2, 1, 7, 9]
y = sorted(x) # 为获取排序后的列表的副本， 另一种方式是使用函数sorted。
x # [4, 6, 2, 1, 7, 9]
y # [1, 2, 4, 6, 7, 9]

sorted('Python')  # 实际上，这个函数可用于任何序列，但总是返回一个列表
['P', 'h', 'n', 'o', 't', 'y']

'''
如果要将元素按相反的顺序排列，可先使用sort（或sorted），再调用方法reverse，也可使
用参数reverse
'''
x = [4, 6, 2, 1, 7, 9]
x.sort()
x.reverse()
x  # [9, 7, 6, 4, 2, 1]

x = [4, 6, 2, 1, 7, 9]
x.sort(reverse=True)   # 逆序排序
x  # [9, 7, 6, 4, 2, 1]


# 高级排序
'''
方法sort接受两个可选参数：key和reverse。这两个参数通常是按名称指定的，称为关键字
参数，将在第6章详细讨论。参数key类似于参数cmp：你将其设置为一个用于排序的函数。然而，
不会直接使用这个函数来判断一个元素是否比另一个元素小，而是使用它来为每个元素创建一个
键，再根据这些键对元素进行排序。因此，要根据长度对元素进行排序，可将参数key设置为函数len。
'''
x = ['aardvark', 'abalone', 'acme', 'add', 'aerate']
x.sort(key=len)
x # ['add', 'acme', 'aerate', 'abalone', 'aardvark']

'''
对于另一个关键字参数reverse，只需将其指定为一个真值（True或False，将在第5章详细介
绍），以指出是否要按相反的顺序对列表进行排序。
'''
x = [4, 6, 2, 1, 7, 9]
x.sort(reverse=True)  # 逆序排序
x # [9, 7, 6, 4, 2, 1]
# 函数sorted也接受参数key和reverse。在很多情况下，将参数key设置为一个自定义函数很有用


# tuple 元组：不可修改的序列
'''
与列表一样，元组也是序列，唯一的差别在于元组是不能修改的（你可能注意到了，字符串
也不能修改）。元组语法很简单，只要将一些值用逗号分隔，就能自动创建一个元组。
>>> 1, 2, 3
(1, 2, 3)
'''

(1, 2, 3)  # 如你所见，tuple元组还可用圆括号括起（这也是通常采用的做法）。

() # empty tuple 空元组用两个不包含任何内容的圆括号表示。

'''
你可能会问，如何表示只包含一个值的元组呢？这有点特殊：虽然只有一个值，也必须在它
后面加上逗号。
>>> 42
42
>>> 42,    # single element tuple # 这有点特殊：虽然只有一个值，也必须在它后面加上逗号
(42,)
>>> (42,)  # single element tuple
(42,)
'''

'''
逗号至关重要，仅将
值用圆括号括起不管用：(42)与42完全等效。但仅仅加上一个逗号，就能完全改变表达式的值。
>>> 3 * (40 + 2)
126
>>> 3 * (40 + 2,)
(42, 42, 42)
'''

'''
函数tuple的工作原理与list很像：它将一个序列作为参数，并将其转换为元组①。如果参数
已经是元组，就原封不动地返回它 (与list一样，tuple实际上也不是函数，而是类型)
>>> tuple([1, 2, 3])
(1, 2, 3)
>>> tuple('abc')
('a', 'b', 'c')
>>> tuple((1, 2, 3))
(1, 2, 3)
'''

'''
你可能意识到了，元组并不太复杂，而且除创建和访问其元素外，可对元组执行的操作不多。
元组的创建及其元素的访问方式与其他序列相同
>>> x = 1, 2, 3
>>> x[1]   # 元组的索引操作
2
>>> x[0:2] # 元组的切片操作
(1, 2)
'''

'''
元组的切片也是元组，就像列表的切片也是列表一样。为何要熟悉元组呢？原因有以下两个。
    1.它们用作映射中的键（以及集合的成员），而列表不行。映射将在第4章详细介绍。
    2.有些内置函数和方法返回元组，这意味着必须跟它们打交道。只要不尝试修改元组，与
      元组“打交道”通常意味着像处理列表一样处理它们（需要使用元组没有的index和count
      等方法时例外）。
    一般而言，使用列表足以满足对序列的需求。
'''




































